#!/usr/bin/env nix-shell
#! nix-shell -i python3 -p python3 python35Packages.paramiko python35Packages.pycrypto

import paramiko
import fileinput
import sys
from Crypto.Cipher import AES
from Crypto.Protocol.KDF import PBKDF2
from os import urandom
import os
import base64
import struct

def encrypt(ssh_key, infile, outfile):
    challenge = urandom(1024)
    key = ssh_key.sign_ssh_data(challenge)
    key = base64.b64encode(key).decode('ascii')
    key = PBKDF2(key, b'12345678', 32, 1000)

    chunksize = AES.block_size
    iv = urandom(16)
    encryptor = AES.new(key, AES.MODE_CBC, iv)

    outfile.write(iv)
    outfile.write(challenge)

    filesize = 0
    while True:
        chunk = infile.read(chunksize)
        filesize = filesize + len(chunk)
        if len(chunk) == 0:
            break
        elif len(chunk) % 16 != 0:
            chunk += ' ' * (16 - len(chunk) % 16)

        outfile.write(encryptor.encrypt(chunk))
    # that is an unsigned long long, so last 8 bytes of the stream
    outfile.write(struct.pack('<Q', filesize))

def decrypt(ssh_key, infile, outfile, chunksize=24*1024):
    iv = infile.read(16)
    challenge = infile.read(1024)
    key = ssh_key.sign_ssh_data(challenge)
    key = base64.b64encode(key).decode('ascii')
    key = PBKDF2(key, b'12345678', 32, 1000)
    decryptor = AES.new(key, AES.MODE_CBC, iv)
    lebsize = struct.calcsize('Q')
    lastchunk = None
    written = 0
    origsize = None

    while origsize == None:
        chunk = infile.read(chunksize)
        if len(chunk) == 0:
            origsize = struct.unpack('<Q', lastchunk[-lebsize:])[0]
            lastchunk = lastchunk[:-lebsize]

        # TODO the LEB breaks the decryptor
        if lastchunk:
            decrypted = decryptor.decrypt(lastchunk)
            if origsize != None:
                decrypted = decrypted[:(origsize - written)]
            outfile.write(decrypted)
            written = written + len(decrypted)
        lastchunk = chunk

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print('usage: %s <fingerprint> <encrypt | decrypt>' % (sys.argv[0]),
              file=sys.stderr)
        sys.exit(3)

    target_key = sys.argv[1]
    mode = sys.argv[2]

    agent = paramiko.Agent()
    for key in agent.get_keys():
        if key.get_base64() == target_key:
            ssh_key = key
            break
    else:
        print('no key with fingerprint %s' % target_key, file=sys.stderr)
        sys.exit(1)

    try:
        #print(mode, target_key, file=sys.stderr)
        if mode == 'encrypt':
            encrypt(ssh_key, sys.stdin.buffer, sys.stdout.buffer)
        elif mode == 'decrypt':
            decrypt(ssh_key, sys.stdin.buffer, sys.stdout.buffer)
        else:
            print('unknown mode %s' % (mode, ), file=sys.stderr)
            sys.exit(3)
        sys.stdout.buffer.flush()
    except:
        e = sys.exc_info()
        print('%s occurred in %s' % (e[0], mode, ), file=sys.stderr)
        import traceback
        traceback.print_exc()
        sys.exit(2)
